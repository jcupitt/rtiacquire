#!/usr/bin/python

"""This module wraps up libgphoto2 in a nice interface.

Camera -- a connection to a camera
Error -- the exception we can raise
Widget -- a camera setting
Config -- read and write camera settings

Author: J.Cupitt
Created as part of the AHRC RTI project in 2011
GNU LESSER GENERAL PUBLIC LICENSE
"""

import logging
import os
import sys
import re
import ctypes

import finalize

# track the detailed part of the last error generated by a subsystem here
# we present it with a summary during error messages
last_detail = ""

class Error(Exception):

    """An error from the camera.

    message -- a high-level description of the error
    detail -- a string with some detailed diagnostics
    """

    def __init__(self, message, detail=None):
        global last_detail

        self.message = message
        if detail:
            self.detail = detail
        else:
            self.detail = last_detail

        logging.debug('camera: Error %s %s', self.message, self.detail)

    def __str__(self):
        return '%s - %s' % (self.message, self.detail)

# gphoto structures
""" From 'gphoto2-camera.h'
typedef struct {
        char name [128];
        char folder [1024];
} CameraFilePath;
"""

class CameraFilePath(ctypes.Structure):
    _fields_ = [('name',(ctypes.c_char * 128)),
                ('folder',(ctypes.c_char * 1024))]

# we need to be able to pass a va_list on in the log function ... va_list is
# 24 bytes on linux64, or 3 pointers
class VaList(ctypes.Structure):
    _fields_ = [('value',(ctypes.c_void_p * 3))]

# gphoto constants
# Defined in 'gphoto2-port-result.h'
GP_OK = 0
GP_ERROR = -1 #generic error
GP_ERROR_BAD_PARAMETERS = -2 #bad parameters passed
GP_ERROR_NO_MEMORY = -3 # out of memory
GP_ERROR_LIBRARY = -4 # error in camera driver
GP_ERROR_UNKNOWN_PORT = -5 #unknown libgphoto2 port passed
GP_ERROR_NOT_SUPPORTED = -6 #whatever you tried isn't supported
GP_ERROR_IO = -7 # Generic I/O error - there's a surprise
GP_ERROR_FIXED_LIMIT_EXCEEDED = -8 # internal buffer overflow
GP_ERROR_TIMEOUT = -10 #timeout - no prizes for guessing that one
GP_ERROR_IO_SUPPORTED_SERIAL = -20 #Serial port not supported
GP_ERROR_IO_SUPPORTED_USB = -21 #USB ports not supported
GP_ERROR_IO_INIT = -31 #Unable to init I/O
GP_ERROR_IO_READ = -34 # I/O Error during read
GP_ERROR_IO_WRITE = -35 # I/O Error during write
GP_ERROR_IO_UPDATE = -37 #I/O during update of settings
GP_ERROR_IO_SERIAL_SPEED = -41 # Serial speed not possible
GP_ERROR_IO_USB_CLEAR_HALT = -51 #Error
# CameraCaptureType enum in 'gphoto2-camera.h'
GP_CAPTURE_IMAGE = 0
# CameraFileType enum in 'gphoto2-file.h'
GP_FILE_TYPE_NORMAL = 1

""" gphoto2-port-log.h
typedef enum {
    GP_LOG_ERROR = 0,       /**< \brief Log message is an error infomation. */
    GP_LOG_VERBOSE = 1,     /**< \brief Log message is an verbose debug infomation. */
    GP_LOG_DEBUG = 2,       /**< \brief Log message is an debug infomation. */
    GP_LOG_DATA = 3         /**< \brief Log message is a data hex dump. */
} GPLogLevel;
"""
GP_LOG_ERROR = 0
GP_LOG_VERBOSE = 1
GP_LOG_DEBUG = 2
GP_LOG_DATA = 3
GPLogLevel = {GP_LOG_ERROR: "error", 
                GP_LOG_VERBOSE: "verbose", 
                GP_LOG_DEBUG: "debug", 
                GP_LOG_DATA: "data"}

# Load library
if sys.platform == "linux2":
    gp = ctypes.CDLL('libgphoto2.so.6')
elif sys.platform == "darwin":
    gp = ctypes.CDLL('libgphoto2.dylib')
else:
    logging.error("unsupported platform")

# gphoto2 log function
#   void log(GPLogLevel level, const char *domain, 
#       const char *format, va_list args, void *data);
# calling libc.snprintf() is a segv each time heh just show the fmt for now
# annoyingly, many successful operations also generate errors, making this
# output only really useful for debugging
LOGFUNC = ctypes.CFUNCTYPE(None, 
                ctypes.c_int, ctypes.c_char_p, ctypes.c_char_p,
                VaList, ctypes.c_void_p)
def gplog(level, domain, fmt, args, data):
    global last_detail

    # this happens very often when the preview grab fails, hide it to stop the
    # logs going crazy

    # more recent versions of libgphoto have downgraded this to a warning 
    # anyway

    if domain == "ptp2/usb_getresp":
        if fmt == "request code 0x%04x getting resp error 0x%04x":
            return

    # buf = ctypes.create_string_buffer(1024)
    # libc.vsnprintf(buf, 1024, fmt, args)
    if level == GP_LOG_ERROR:
        logging.error("%s - %s: %s", GPLogLevel[level], domain, fmt)
    elif debug:
        logging.debug("%s - %s: %s", GPLogLevel[level], domain, fmt)

    # sometimes we get a %s and the actual message is hidden in the args, argh
    # hide this since it looks bad
    if fmt != '%s':
        last_detail = fmt
    else:
        last_detail = 'Non-specific error'
gplog_func = LOGFUNC(gplog)

gp.gp_context_new.restype = ctypes.c_void_p
context = ctypes.c_void_p(gp.gp_context_new())

gp.gp_log_add_func(GP_LOG_ERROR, gplog_func, None)

class Camera:

    """Talk to a camera with libgphoto2."""

    def __init__(self):
        """Does almost nothing. The camera connection is made on the first
        operation.
        """
        self.camera = None
        self.preview_file = ctypes.c_void_p()
        gp.gp_file_new(ctypes.byref(self.preview_file))

    def set_canon_capture(self, onoff):
        """Enable Canon preview mode.

        Canon cameras have to have this extra setting turned on, apparently.
        Calling this for non-canon cameras is harmless.

        onoff - 1 to enable preview, 0 to disable
        """
        try:
            config = Config(self)
            widget = config.get_root_widget().get_child_by_name('capture')
            widget.set_value(onoff)
            config.set_config()
        except:
            pass

    def connect(self):
        """Connect to the camera.

        If currently unattached, automatically connect to any attached 
        camera. This method is called for you before any camera operation.
        """
        if self.camera == None:
            logging.debug('** camera init')
            self.camera = ctypes.c_void_p()
            gp.gp_camera_new(ctypes.byref(self.camera))
            retval = gp.gp_camera_init(self.camera, context)
            if retval != GP_OK:
                 self.release()
                 raise Error('Unable to connect to camera')
            self.set_canon_capture(1)
            logging.debug('** camera connected')

    def release(self):
        """Drop the camera connection. 
        
        Calling this method will force reconnection on the next camera
        operation.
        """
        if self.camera != None:
            logging.debug('** camera shutdown')
            gp.gp_camera_exit(self.camera, context)
            gp.gp_camera_unref(self.camera)
            self.camera = None

    def capture_to_file(self, filename):

        """Connect and capture photo to filename. 
        
        The photo is deleted from the camera. This method can raise
        camera.Error. 

        Return the full filename we downloaded to, including the camera's
        preferred filename suffix.
        """

        self.connect()

        logging.debug('** camera capture')
        cam_path = CameraFilePath()
        logging.debug("after path")
        retval = gp.gp_camera_capture(self.camera, 
                        GP_CAPTURE_IMAGE, ctypes.byref(cam_path), context)

        if retval != GP_OK:
            raise Error('Unable to capture')
        else:
            logging.debug("Capture OK")

        logging.debug('name = "%s"', cam_path.name)
        logging.debug('folder = "%s"', cam_path.folder)

        # we need the camera's suggested filename suffix
        match = re.match(r".*\.([^\.]+)", cam_path.name)
        suffix = "jpg"
        if match != None:
            suffix = match.group(1)
        logging.debug('suffix = "%s"', suffix)
        full_filename = filename + '.' + suffix

        # Download and delete
        logging.debug('** camera download to %s', full_filename)
        cam_file = ctypes.c_void_p()
        fd = os.open(full_filename, os.O_CREAT | os.O_WRONLY)
        gp.gp_file_new_from_fd(ctypes.byref(cam_file), fd)
        retval = gp.gp_camera_file_get(self.camera, 
                        cam_path.folder, cam_path.name, GP_FILE_TYPE_NORMAL, 
                        cam_file, context)

        if retval != GP_OK:
            gp.gp_file_unref(cam_file)
            raise Error('Unable to download')
        else:
            logging.debug("Download complete")        

        logging.debug('** camera delete')
        retval = gp.gp_camera_file_delete(self.camera, 
                        cam_path.folder, cam_path.name, context)
        if retval != GP_OK:
            logging.error('delete error')
        else:
            logging.debug("delete complete")
        gp.gp_file_unref(cam_file)

        self.release()

        return full_filename

    def preview(self):

        """Connect and capture a preview frame. 
        
        Return the preview as a(data, length) tuple pointing to a memory
        area containing a jpeg-compressed image. The data poiner is only valid
        until the next call to preview().

        Preview can fail for short periods. If you get None back, try again
        later.
        """

        self.connect()

        logging.debug('** camera preview')
        retval = gp.gp_camera_capture_preview(self.camera, 
                        self.preview_file, context)
        if retval != GP_OK:
            logging.error('preview capture error')
            return None

        data = ctypes.c_void_p();
        length = ctypes.c_ulong();
        retval = gp.gp_file_get_data_and_size(self.preview_file, 
                        ctypes.byref(data), ctypes.byref(length))
        if retval != GP_OK or data.value == None:
            logging.error('preview fetch error')
            return None

        logging.debug('preview: frame at addr %d, length %d', 
                        data.value, length.value)

        return(data, length)

    def preview_to_file(self, filename):

        """Capture a preview frame to a file.

        Capture a low-res preview image to filename. This method can raise
        camera.Error.
        """

        self.connect()

        logging.debug('** camera preview to file %s', filename)
        cam_file = ctypes.c_void_p()
        gp.gp_file_new(ctypes.byref(cam_file))

        # capture preview can fail on a Nikon, retry up to three times
        for i in range(0, 3):
            retval = gp.gp_camera_capture_preview(self.camera, 
                                                  cam_file, context)
            if retval == GP_OK:
                break
            else:
                logging.debug('preview retry %d', i)

        if retval != GP_OK:
            gp.gp_file_unref(cam_file)
            logging.error('preview capture error')
            raise Error('Unable to capture preview')

        retval = gp.gp_file_save(cam_file, filename)
        if retval != GP_OK:
            gp.gp_file_unref(cam_file)
            logging.error('preview save error')
            raise Error('Unable to save preview')

        gp.gp_file_unref(cam_file)

    def config_debug(self):
        self.connect()

        widget = ctypes.c_void_p()
        retval = gp.gp_camera_get_config(self.camera, 
                ctypes.byref(widget), context)
        if retval != GP_OK:
            raise Error('Unable to get config')

        config_print(widget)

        gp.gp_widget_free(widget)

"""
/** 
 * \brief Type of the widget to be created.
 *
 * The actual widget type we want to create. The type of the value
 * it supports depends on this type.
 */
typedef enum {                                  /* Value (get/set): */
    GP_WIDGET_WINDOW,   /**< \brief Window widget
                 *   This is the toplevel configuration widget. It should
                 *   likely contain multiple #GP_WIDGET_SECTION entries.
                 */
    GP_WIDGET_SECTION,  /**< \brief Section widget (think Tab) */
    GP_WIDGET_TEXT,     /**< \brief Text widget. */         /* char *       */
    GP_WIDGET_RANGE,    /**< \brief Slider widget. */           /* float
*/
    GP_WIDGET_TOGGLE,   /**< \brief Toggle widget (think check box) */  /* int
*/
    GP_WIDGET_RADIO,    /**< \brief Radio button widget. */     /* char *
*/
    GP_WIDGET_MENU,     /**< \brief Menu widget (same as RADIO). */ /* char *
*/
    GP_WIDGET_BUTTON,   /**< \brief Button press widget. */     /*
CameraWidgetCallback */
    GP_WIDGET_DATE      /**< \brief Date entering widget. */        /* int
*/
} CameraWidgetType;
"""

GP_WIDGET_WINDOW = 0
GP_WIDGET_SECTION = 1
GP_WIDGET_TEXT = 2
GP_WIDGET_RANGE = 3
GP_WIDGET_TOGGLE = 4
GP_WIDGET_RADIO = 5
GP_WIDGET_MENU = 6
GP_WIDGET_BUTTON = 7
GP_WIDGET_DATE = 8
WidgetType = {
        GP_WIDGET_WINDOW: "window", 
        GP_WIDGET_SECTION: "section", 
        GP_WIDGET_TEXT: "text", 
        GP_WIDGET_RANGE: "range", 
        GP_WIDGET_TOGGLE: "toggle", 
        GP_WIDGET_RADIO: "radio", 
        GP_WIDGET_MENU: "menu", 
        GP_WIDGET_BUTTON: "button", 
        GP_WIDGET_DATE: "date"} 

class Widget:
    """A camera configuration widget. 
    
    See Config for the containg object.

    Widgets have type (eg. GP_WIDGET_RANGE, a value that
    can be set in a range perhaps with a slider), value (eg. 12.3), name (eg.
    "exposuresetting"), label (eg. "Camera Exposure") and, depending on the
    type, extra values you can grab such as (min, max, inc) via get_range().

    Widgets of type GP_WIDGET_SECTION and GP_WIDGET_WINDOW have children. Use
    get_children() to get a list of the child widgets.
    """

    def __init__(self, widget):
        """Wrap a Widget instance around the underlying gphoto2 pointer."""
        self.widget = widget

    def get_nchildren(self):
        return gp.gp_widget_count_children(self.widget)

    def get_child(self, i):
        child = ctypes.c_void_p()
        retval = gp.gp_widget_get_child(self.widget, i, ctypes.byref(child))
        if retval != GP_OK:
            raise Error('Setting not found')
        return Widget(child)

    def get_child_by_name(self, name):
        child = ctypes.c_void_p()
        retval = gp.gp_widget_get_child_by_name(self.widget, 
                name, ctypes.byref(child))
        if retval != GP_OK:
            raise Error('Setting not found', 
                    'Setting %s not in widget tree.' % name)
        return Widget(child)

    def get_children(self):
        """Return the children of this widget. 
        
        Only SECTION and WINDOW widgets have children.
        """
        children = []
        for i in range(0, self.get_nchildren()):
            children += [self.get_child(i)]
        return children

    def get_wtype(self):
        """Return the type of the widget.

        Widgets may have the following types:

        GP_WIDGET_WINDOW = 0        the top widget
        GP_WIDGET_SECTION = 1       a group of related widgets
        GP_WIDGET_TEXT = 2          a string
        GP_WIDGET_RANGE = 3         see get_range() 
        GP_WIDGET_TOGGLE = 4
        GP_WIDGET_RADIO = 5         see get_choices
        GP_WIDGET_MENU = 6          see get_choices
        GP_WIDGET_BUTTON = 7        not used
        GP_WIDGET_DATE = 8

        """
        wtype = ctypes.c_int()
        gp.gp_widget_get_type(self.widget, ctypes.byref(wtype))
        return wtype.value

    def get_name(self):
        """Return the name of the widget.

        Names are short, unique, text names which can be used to identity the
        widget. See Config.get_widget_by_name().
        """
        name = ctypes.c_char_p()
        gp.gp_widget_get_name(self.widget, ctypes.byref(name))
        return name.value

    def get_label(self):
        """Return the label of the widget. 

        Labels are long, descriptive strings that can be shown to the user.
        """
        label = ctypes.c_char_p()
        gp.gp_widget_get_label(self.widget, ctypes.byref(label))
        return label.value

    def get_value(self):
        """Return the value of the widget.

        The value may be int for TOGGLE, float for RANGE, and a string for
        TEXT, MENU or RADIO.
        """
        wtype = self.get_wtype()
        if wtype == GP_WIDGET_TOGGLE:
            value = ctypes.c_int()
        elif wtype == GP_WIDGET_RANGE:
            value = ctypes.c_float()
        elif wtype in [GP_WIDGET_TEXT, GP_WIDGET_MENU, GP_WIDGET_RADIO]:
            value = ctypes.c_char_p()
        else:
            return None
        gp.gp_widget_get_value(self.widget, ctypes.byref(value))
        return value.value

    # there's info too, but it seems empty, at least for the Nikon

    def get_choices(self):
        """Return the possible choices for a RADIO or MENU widget."""
        nchoices = gp.gp_widget_count_choices(self.widget)
        choices = []
        for i in range (0, nchoices):
            choice = ctypes.c_char_p()
            gp.gp_widget_get_choice(self.widget, i, ctypes.byref(choice))
            choices += [choice.value]
        return choices

    def get_range(self):
        """Return a three-element float tuple of (min, max, inc) for the
        range.
        """
        wmin = ctypes.c_float()
        wmax = ctypes.c_float()
        winc = ctypes.c_float()
        gp.gp_widget_get_range(self.widget, 
                ctypes.byref(wmin), 
                ctypes.byref(wmax), 
                ctypes.byref(winc)) 
        return (wmin.value, wmax.value, winc.value)

    def get_readonly(self):
        """Return True for read-only widgets."""
        readonly = ctypes.c_int()
        gp.gp_widget_get_readonly(self.widget, ctypes.byref(readonly))
        return readonly.value

    def set_value(self, value):
        """Set the value of the widget. 

        value should be float for RANGE, int for toggle and string for TEXT,
        MENU and RADIO.
        """
        wtype = self.get_wtype()
        if wtype == GP_WIDGET_RANGE:
            wvalue = ctypes.c_float()
        elif wtype == GP_WIDGET_TOGGLE:
            wvalue = ctypes.c_int()
        elif wtype in [GP_WIDGET_TEXT, GP_WIDGET_MENU, GP_WIDGET_RADIO]:
            wvalue = ctypes.c_char_p()
        else:
            return None
        wvalue.value = value
        logging.debug('setting %s = %s', self.get_name(), str(wvalue.value))

        # for int/float, we have to pass a pointer to the object
        if wtype in [GP_WIDGET_RANGE, GP_WIDGET_TOGGLE]:
            wvalue = ctypes.byref(wvalue)
        gp.gp_widget_set_value(self.widget, wvalue)

    def set_changed(self, changed):
        wchanged = ctypes.c_int(changed)
        gp.gp_widget_set_changed(self.widget, wchanged)

class Config:
    """Load, modify and save camera configuration."""
    def free_config(self):
        if self.root_widget:
            gp.gp_widget_free(self.root_widget)
            self.root_widget = ctypes.c_void_p()

    def refresh(self):
        self.camera.connect()

        self.free_config()
        self.root_widget = ctypes.c_void_p()
        retval = gp.gp_camera_get_config(self.camera.camera, 
                ctypes.byref(self.root_widget), context)
        if retval != GP_OK:
            raise Error('Unable to get config')

    def __init__(self, camera):
        """Make a Config for a camera. See Camera."""
        self.camera = camera

        self.root_widget = None
        finalize.track(self, self, self.free_config)

        self.refresh()

    def get_root_widget(self):
        """Get the root Widget for a Config. 
        
        Use this to iterate over all widgets. See Widget.
        """
        return Widget(self.root_widget)

    def set_config(self):
        """Write any modifications back to the camera.

        Make any modifications with Widget.set_value(), then write back with
        this. 

        This method can raise camera.Error.
        """
        logging.debug('writing camera config ...')
        retval = gp.gp_camera_set_config(self.camera.camera, 
                self.root_widget, context)
        if retval != GP_OK:
            raise Error('Unable to set config')

    def prettyprint(self, fp, widget, indent=0):
        """Prettyprint the camera settings to a File."""
        wtype = widget.get_wtype()
        label = widget.get_label()
        name = widget.get_name()

        fp.write('%s%s (%s) - %s\n' % 
                (' ' * indent, label, name, WidgetType[wtype]))

        if wtype == GP_WIDGET_RANGE:
            value = widget.get_value()
            wmin, wmax, winc = widget.get_range()
            fp.write('%s(value = %f, min = %f, max = %f, inc = %f)\n' %  
                    (' ' * indent, value, wmin, wmax, winc))

        if wtype == GP_WIDGET_TOGGLE:
            value = widget.get_value()
            fp.write('%s(value = %d)\n' % (' ' * indent, value))

        if wtype == GP_WIDGET_TEXT:
            value = widget.get_value()
            fp.write('%s(value = %s)\n' % (' ' * indent, value))

        if wtype == GP_WIDGET_MENU or wtype == GP_WIDGET_RADIO:
            value = widget.get_value()
            choices = widget.get_choices()
            fp.write('%s(value = %s, choices = %s)\n' % 
                    (' ' * indent, value, choices))

        # ignore DATE, it's fiddly 
        # WINDOW is only for the top-level, BUTTON is never used
        # SECTION just encloses children

        for child in widget.get_children():
            self.prettyprint(fp, child, indent + 2)
